<!DOCTYPE html>
<html lang="en">
<!-- Head section remains the same -->
<head>
    <!-- Previous head content remains exactly the same -->
    <title>3D N-Back Training</title>
    <style>
        /* Previous styles remain exactly the same */
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="nback-display">N = 1</div>
    <div id="controls">
        <button onclick="toggleAutoPlay()">Start/Stop</button>
        <button id="matchButton" onclick="checkAnswer()">Match?</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script>
        // Previous configuration remains the same
        const CONFIG = {
            rotationSpeed: 0.01,
            cubeDisplayTime: 1000,
            intervalTime: 3000,
            feedbackTime: 500,
            cubeColor: 0x7fb3d5,
            nBack: 1,
            lineWidth: 2  // Added line width configuration
        };

        // Previous variable declarations remain the same
        let scene, camera, renderer, grid, currentCube;
        let positionHistory = [];
        let autoPlayInterval = null;
        const gridSize = 2;
        const spacing = 1;
        let isAutoPlaying = false;

        // Init function remains the same
        function init() {
            // Previous init code remains exactly the same
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            camera.position.z = 5;
            camera.position.y = 2;
            camera.lookAt(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            createGrid();
            animate();

            window.addEventListener('resize', onWindowResize, false);
        }

        // Feedback function remains the same
        function showFeedback(isCorrect) {
            // Previous feedback code remains exactly the same
        }

        function createGrid() {
            grid = new THREE.Group();

            // Create reference axes with thicker lines
            const axesHelper = new THREE.Group();
            
            // X axis (red)
            const xGeometry = new THREE.BufferGeometry();
            xGeometry.setFromPoints([
                new THREE.Vector3(-spacing, -spacing, -spacing),
                new THREE.Vector3(spacing, -spacing, -spacing)
            ]);
            const xLine = new THREE.Line(
                xGeometry,
                new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: CONFIG.lineWidth })
            );
            axesHelper.add(xLine);

            // Y axis (green)
            const yGeometry = new THREE.BufferGeometry();
            yGeometry.setFromPoints([
                new THREE.Vector3(-spacing, -spacing, -spacing),
                new THREE.Vector3(-spacing, spacing, -spacing)
            ]);
            const yLine = new THREE.Line(
                yGeometry,
                new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: CONFIG.lineWidth })
            );
            axesHelper.add(yLine);

            // Z axis (blue)
            const zGeometry = new THREE.BufferGeometry();
            zGeometry.setFromPoints([
                new THREE.Vector3(-spacing, -spacing, -spacing),
                new THREE.Vector3(-spacing, -spacing, spacing)
            ]);
            const zLine = new THREE.Line(
                zGeometry,
                new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: CONFIG.lineWidth })
            );
            axesHelper.add(zLine);

            grid.add(axesHelper);

            // Create unified wireframe
            const lines = new THREE.Group();

            // Create vertical lines
            for (let x = 0; x <= gridSize; x++) {
                for (let z = 0; z <= gridSize; z++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(
                            (x - gridSize/2) * spacing, 
                            -gridSize/2 * spacing, 
                            (z - gridSize/2) * spacing
                        ),
                        new THREE.Vector3(
                            (x - gridSize/2) * spacing, 
                            gridSize/2 * spacing, 
                            (z - gridSize/2) * spacing
                        )
                    ];
                    geometry.setFromPoints(points);
                    const line = new THREE.Line(
                        geometry,
                        new THREE.LineBasicMaterial({ 
                            color: 0x4444ff,
                            linewidth: CONFIG.lineWidth
                        })
                    );
                    lines.add(line);
                }
            }

            // Create horizontal lines (X axis)
            for (let y = 0; y <= gridSize; y++) {
                for (let z = 0; z <= gridSize; z++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(
                            -gridSize/2 * spacing,
                            (y - gridSize/2) * spacing,
                            (z - gridSize/2) * spacing
                        ),
                        new THREE.Vector3(
                            gridSize/2 * spacing,
                            (y - gridSize/2) * spacing,
                            (z - gridSize/2) * spacing
                        )
                    ];
                    geometry.setFromPoints(points);
                    const line = new THREE.Line(
                        geometry,
                        new THREE.LineBasicMaterial({ 
                            color: 0x4444ff,
                            linewidth: CONFIG.lineWidth
                        })
                    );
                    lines.add(line);
                }
            }

            // Create depth lines (Z axis)
            for (let x = 0; x <= gridSize; x++) {
                for (let y = 0; y <= gridSize; y++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(
                            (x - gridSize/2) * spacing,
                            (y - gridSize/2) * spacing,
                            -gridSize/2 * spacing
                        ),
                        new THREE.Vector3(
                            (x - gridSize/2) * spacing,
                            (y - gridSize/2) * spacing,
                            gridSize/2 * spacing
                        )
                    ];
                    geometry.setFromPoints(points);
                    const line = new THREE.Line(
                        geometry,
                        new THREE.LineBasicMaterial({ 
                            color: 0x4444ff,
                            linewidth: CONFIG.lineWidth
                        })
                    );
                    lines.add(line);
                }
            }

            grid.add(lines);
            scene.add(grid);
        }

        // All other functions remain exactly the same
        // generateNewPosition, toggleAutoPlay, checkAnswer, animate, onWindowResize

    </script>
</body>
</html>